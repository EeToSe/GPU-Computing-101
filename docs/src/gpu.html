<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How a GPU works – GPU Computing 101</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.jpg" rel="icon" type="image/jpeg">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-9344fb9851b4da3cab95007ef9d770dc.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="How a GPU works – GPU Computing 101">
<meta property="og:description" content="">
<meta property="og:site_name" content="GPU Computing 101">
</head>

<body class="nav-sidebar floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">GPU Computing 101</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EeToSe/GPU-Computing"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">How a GPU works</li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Architecture</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
 <span class="menu-text">docs/cpu.qmd</span>
  </li>
          <li class="sidebar-item">
 <span class="menu-text">docs/gpu.qmd</span>
  </li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#gpu-vs-cpu" id="toc-gpu-vs-cpu" class="nav-link active" data-scroll-target="#gpu-vs-cpu">GPU vs CPU</a></li>
  <li><a href="#gpu-hierarchy-nvidia-ga102" id="toc-gpu-hierarchy-nvidia-ga102" class="nav-link" data-scroll-target="#gpu-hierarchy-nvidia-ga102">GPU Hierarchy (NVIDIA GA102)</a></li>
  <li><a href="#one-chip-multiple-products-binning" id="toc-one-chip-multiple-products-binning" class="nav-link" data-scroll-target="#one-chip-multiple-products-binning">One Chip, Multiple Products (Binning)</a></li>
  <li><a href="#inside-a-cuda-core-fp32-alu" id="toc-inside-a-cuda-core-fp32-alu" class="nav-link" data-scroll-target="#inside-a-cuda-core-fp32-alu">Inside a CUDA Core (FP32 ALU)</a></li>
  <li><a href="#graphic-card-components" id="toc-graphic-card-components" class="nav-link" data-scroll-target="#graphic-card-components">Graphic card components</a></li>
  <li><a href="#graphics-memory-vram" id="toc-graphics-memory-vram" class="nav-link" data-scroll-target="#graphics-memory-vram">Graphics Memory (VRAM)</a></li>
  <li><a href="#embarrassingly-parallel" id="toc-embarrassingly-parallel" class="nav-link" data-scroll-target="#embarrassingly-parallel">“Embarrassingly Parallel”</a></li>
  <li><a href="#mapping-computation-to-hardware-simd-simt" id="toc-mapping-computation-to-hardware-simd-simt" class="nav-link" data-scroll-target="#mapping-computation-to-hardware-simd-simt">Mapping Computation to Hardware (SIMD → SIMT)</a></li>
  <li><a href="#tensor-cores-matrix-engines" id="toc-tensor-cores-matrix-engines" class="nav-link" data-scroll-target="#tensor-cores-matrix-engines">Tensor Cores — Matrix Engines</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">How a GPU works</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>How many calculations do graphics cards perform:</p>
<ul>
<li><strong>Mario 64 (1996):</strong> ~<strong>100 million</strong> calculations/s.</li>
<li><strong>Minecraft (2011):</strong> ~<strong>100 billion</strong> calculations/s.</li>
<li><strong>Cyberpunk 2077:</strong> ~<strong>36 trillion</strong> calculations/s.</li>
</ul>
<p><strong>Intuition:</strong> To match <strong>36T calc/s</strong>, imagine <strong>~4,400 Earths</strong> where every person completes <strong>1 calculation each second</strong>.</p>
<section id="gpu-vs-cpu" class="level2">
<h2 class="anchored" data-anchor-id="gpu-vs-cpu">GPU vs CPU</h2>
<ul>
<li><strong>GPU:</strong> “<strong>&gt;10,000 cores</strong>,” optimized for <strong>massively parallel</strong>, <strong>simple</strong> arithmetic; <strong>cannot</strong> run OS or directly interface with input devices or networks.</li>
<li><strong>CPU:</strong> “<strong>~24 cores</strong>,” higher per-core speed; <strong>flexible</strong> instruction support; runs OS and diverse I/O.</li>
<li><strong>Analogy:</strong> GPU = <strong>cargo ship</strong> (huge throughput, slower per unit). CPU = <strong>jumbo jet</strong> (lower throughput, faster per unit, flexible).</li>
</ul>
</section>
<section id="gpu-hierarchy-nvidia-ga102" class="level2">
<h2 class="anchored" data-anchor-id="gpu-hierarchy-nvidia-ga102">GPU Hierarchy (NVIDIA GA102)</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Level</th>
<th style="text-align: left;">Component</th>
<th style="text-align: left;">Count per Parent Component</th>
<th style="text-align: left;">Total Count (on GPU)</th>
<th style="text-align: left;">Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>1. Chip</strong></td>
<td style="text-align: left;"><strong>Full GA102 GPU</strong></td>
<td style="text-align: left;">N/A</td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;">Contains 28.3 billion transistors.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>2. Cluster</strong></td>
<td style="text-align: left;"><strong>Graphics Processing Cluster (GPC)</strong></td>
<td style="text-align: left;"><strong>7</strong> GPCs per GPU</td>
<td style="text-align: left;"><strong>7</strong></td>
<td style="text-align: left;">The highest-level logical block.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>3. Processor</strong></td>
<td style="text-align: left;"><strong>Streaming Multiprocessor (SM)</strong></td>
<td style="text-align: left;"><strong>12</strong> SMs per GPC</td>
<td style="text-align: left;"><strong>84</strong></td>
<td style="text-align: left;">The main processing engine of the GPU.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>4. Scheduler</strong></td>
<td style="text-align: left;"><strong>Warp Scheduler / Processing Block</strong></td>
<td style="text-align: left;"><strong>4</strong> Schedulers per SM</td>
<td style="text-align: left;"><strong>336</strong></td>
<td style="text-align: left;">Manages and dispatches warps (groups of 32 threads).</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>5. Core</strong></td>
<td style="text-align: left;"><strong>CUDA Core</strong></td>
<td style="text-align: left;"><strong>32</strong> CUDA Cores per Scheduler</td>
<td style="text-align: left;"><strong>10,752</strong></td>
<td style="text-align: left;">Executes floating-point and integer math.</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"><strong>Tensor Core</strong></td>
<td style="text-align: left;"><strong>1</strong> Tensor Core per Scheduler</td>
<td style="text-align: left;"><strong>336</strong></td>
<td style="text-align: left;">Accelerates AI matrix calculations.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"><strong>Ray Tracing (RT) Core</strong></td>
<td style="text-align: left;"><strong>1</strong> RT Core per <strong>SM</strong></td>
<td style="text-align: left;"><strong>84</strong></td>
<td style="text-align: left;">Accelerates ray-triangle intersection tests.</td>
</tr>
</tbody>
</table>
</section>
<section id="one-chip-multiple-products-binning" class="level2">
<h2 class="anchored" data-anchor-id="one-chip-multiple-products-binning">One Chip, Multiple Products (Binning)</h2>
<p>During the manufacturing process, sometimes patterning errors, dust particles, or other manufacturing issues cause damage and create defective areas of the circuit. Instead of throwing out the entire chip because of a small defect, engineers find the defective region and permanently isolate and deactivate the nearby circuitry. By having a GPU with a highly repetitive design, a small defect in one core only damages that particular streaming multiprocessor circuit and doesn’t affect the other areas of the chip. As a result, these chips are tested and categorized, or binned, according to the number of defects.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Model</th>
<th style="text-align: left;">CUDA Cores</th>
<th style="text-align: left;">Active SMs</th>
<th style="text-align: left;">SMs Disabled</th>
<th style="text-align: left;">Boost Clock (MHz)</th>
<th style="text-align: left;">Memory</th>
<th style="text-align: left;">Release Date</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>RTX 3080</strong></td>
<td style="text-align: left;">8,704</td>
<td style="text-align: left;">68</td>
<td style="text-align: left;">16</td>
<td style="text-align: left;">1710</td>
<td style="text-align: left;">10 GB</td>
<td style="text-align: left;">September 17, 2020</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>RTX 3080 Ti</strong></td>
<td style="text-align: left;">10,240</td>
<td style="text-align: left;">80</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">1665</td>
<td style="text-align: left;">12 GB</td>
<td style="text-align: left;">June 3, 2021</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>RTX 3090</strong></td>
<td style="text-align: left;">10,496</td>
<td style="text-align: left;">82</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">1695</td>
<td style="text-align: left;">24 GB</td>
<td style="text-align: left;">September 24, 2020</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>RTX 3090 Ti</strong></td>
<td style="text-align: left;">10,752</td>
<td style="text-align: left;">84</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">1860</td>
<td style="text-align: left;">24 GB</td>
<td style="text-align: left;">March 29, 2022</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Same GA102</strong> used across <strong>RTX 3080, 3080 Ti, 3090, 3090 Ti</strong>.</li>
<li><strong>Yield/defect handling:</strong> isolate defective regions; disable affected SMs; <strong>bin</strong> by working units.</li>
<li><strong>Also differ by:</strong> <strong>max clock</strong>, <strong>VRAM quantity/generation</strong>.</li>
</ul>
</section>
<section id="inside-a-cuda-core-fp32-alu" class="level2">
<h2 class="anchored" data-anchor-id="inside-a-cuda-core-fp32-alu">Inside a CUDA Core (FP32 ALU)</h2>
<ul>
<li><p>A <strong>CUDA core</strong> = 1 FP32 ALU capable of one <strong>FMA (A×B + C)</strong> per clock (2 FLOPs).</p></li>
<li><p>Each <strong>SM</strong> in GA102 (Ampere) has</p>
<ul>
<li><strong>128 FP32 cores</strong>.</li>
<li><strong>2 FP64 ALUs</strong> (double-precision), far fewer than FP32 — ~1/64 FP32 throughput.</li>
<li><strong>INT32 ALUs</strong> — in Ampere, half of FP32 cores are <em>hybrid FP32/INT32</em> units, which can execute either FP32 or INT32 per cycle.</li>
<li><strong>4 Tensor Cores</strong> (3rd gen) for matrix multiply-accumulate at lower precisions (FP16, BF16, TF32, INT8, INT4).</li>
<li><strong>1 RT Core</strong> for ray tracing.</li>
<li>Special Function Units (SFUs), Load/Store units, warp schedulers.</li>
</ul></li>
<li><p><strong>Most common method for theoretical FP32 peak:</strong></p>
<p><span class="math display">\[
\text{Peak FLOPS} = (\text{\#FP32 cores}) \times (\text{clock freq}) \times 2
\]</span> For RTX 3090: <span class="math inline">\(10{,}496 \times 1.70\,\text{GHz} \times 2 \approx 35.7\)</span> TFLOPS FP32.</p></li>
<li><p>Actual achieved FLOPS depend heavily on instruction mix, memory bandwidth, and pipeline utilization — real workloads often achieve a fraction of the peak.</p></li>
</ul>
</section>
<section id="graphic-card-components" class="level2">
<h2 class="anchored" data-anchor-id="graphic-card-components">Graphic card components</h2>
<p><strong>On-die (GA102)</strong></p>
<ul>
<li><strong>Memory controllers:</strong> 12 × 32-bit GDDR6X controllers (384-bit total), positioned around die edges for shortest routing.</li>
<li><strong>NVLink controllers:</strong> Present only on RTX 3090 and pro SKUs, absent on some consumer GA102 cards.</li>
<li><strong>PCIe interface:</strong> PCIe 4.0 controller and PHY integrated on die.</li>
<li><strong>L2 cache:</strong> 6 MB unified SRAM, distributed near memory controllers.</li>
<li><strong>GigaThread Engine:</strong> Global scheduler managing all GPCs (Graphics Processing Clusters) and SMs.</li>
</ul>
<p><strong>On the graphics card PCB</strong></p>
<ul>
<li><strong>Display outputs:</strong> Typically 3× DisplayPort 1.4a + 1× HDMI 2.1 (FE layout; AIB may vary).</li>
<li><strong>Power input:</strong> 12-pin NVIDIA connector (FE) or 2–3× 8-pin PCIe connectors; delivers +12 V.</li>
<li><strong>PCIe edge connector:</strong> ×16, Gen 4.0; provides power (max 75 W) and data lanes.</li>
<li><strong>Voltage Regulator Module (VRM):</strong> Steps 12 V down to ~0.7–1.1 V for GPU core, ~1.35 V for GDDR6X; capable of supplying hundreds of watts (300–400 A).</li>
</ul>
</section>
<section id="graphics-memory-vram" class="level2">
<h2 class="anchored" data-anchor-id="graphics-memory-vram">Graphics Memory (VRAM)</h2>
<ul>
<li><p>The graphics card has <strong>24 gigabytes of GDDR6X SDRAM</strong> (graphics memory).</p></li>
<li><p>The GPU contains a very small <strong>6-megabyte Level 2 cache</strong> for immediate data access.</p></li>
<li><p>During loading screens, 3D models are moved from the <strong>solid-state drive (SSD)</strong> into the graphics memory.</p></li>
<li><p>To render a game, data is continuously transferred between the graphics memory and the GPU’s cache.</p></li>
<li><p>The graphics memory has a <strong>384-bit bus width</strong>, which is the amount of data it can transfer simultaneously.</p></li>
<li><p>This results in a total bandwidth of approximately <strong>1.15 terabytes per second (TB/s)</strong>.</p></li>
<li><p>For comparison, the CPU’s standard memory (DRAM) has a much smaller <strong>64-bit bus width</strong> and a bandwidth of only <strong>~64 gigabytes per second (GB/s)</strong>.</p></li>
</ul>
<p><strong>Signaling/encoding:</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 38%">
<col style="width: 23%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>Step</th>
<th>Calculation</th>
<th>Result</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CK (Base)</td>
<td>Given</td>
<td>1219 MHz</td>
<td>Command clock.</td>
</tr>
<tr class="even">
<td>WCK (High-Speed Mode)</td>
<td>4 × CK</td>
<td>4876 MHz</td>
<td>QDR mode ratio for peak performance.</td>
</tr>
<tr class="odd">
<td>Symbol Rate</td>
<td>2 × WCK (DDR)</td>
<td>9752 Msymbols/s</td>
<td>Transfers on both clock edges; equivalent to 8 × CK.</td>
</tr>
<tr class="even">
<td>Effective Data Rate (with PAM-4)</td>
<td>Symbol Rate × 2</td>
<td>19.5 Gbps</td>
<td>GDDR6X-specific; bits per symbol doubles bandwidth.</td>
</tr>
<tr class="odd">
<td>Bus Width</td>
<td>Given</td>
<td>384 bits</td>
<td>Number of data pins in the memory interface.</td>
</tr>
<tr class="even">
<td>Total Throughput</td>
<td>Effective Data Rate × Bus Width</td>
<td>7488 Gbits/s</td>
<td>Aggregate bit rate across all pins (19.5 Gbps/pin × 384 pins).</td>
</tr>
<tr class="odd">
<td>Memory Bandwidth</td>
<td>Total Throughput / 8</td>
<td>936 GB/s</td>
<td>Converted from bits to bytes (divide by 8 bits/byte) for standard bandwidth metric.</td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong>GDDR6X:</strong> <strong>PAM-4</strong> (2 bits per symbol via 4 voltage levels).</p></li>
<li><p><strong>GDDR7:</strong> <strong>PAM-3</strong> (ternary digits, voltages <strong>−1/0/+1</strong>).</p>
<ul>
<li>Example from talk: <strong>3 binary bits → 2 ternary digits</strong>; combined with an <strong>11-bit → 7 ternary-digit</strong> scheme → <strong>send 276 binary bits using 176 ternary digits</strong>.</li>
</ul></li>
<li><p><strong>Motivation for PAM-3:</strong> reduce <strong>encoder complexity</strong>, improve <strong>SNR</strong>, improve <strong>power efficiency</strong>.</p></li>
</ul>
<p><strong>High-Bandwidth Memory (HBM) for AI</strong></p>
<ul>
<li><strong>Structure:</strong> stacked DRAM with <strong>TSVs</strong> (through-silicon vias) → “memory cube” around AI chips.</li>
<li><strong>HBM3E capacities:</strong> <strong>24–36 GB per cube</strong>; <strong>up to ~192 GB</strong> around one AI chip.</li>
<li><strong>Claim:</strong> <strong>~30% less power</strong> than “competitive products”.</li>
<li><strong>System context:</strong> AI accelerator systems <strong>$25–40k</strong>; often <strong>backordered</strong>.</li>
</ul>
</section>
<section id="embarrassingly-parallel" class="level2">
<h2 class="anchored" data-anchor-id="embarrassingly-parallel">“Embarrassingly Parallel”</h2>
<ul>
<li><strong>Definition:</strong> problems that need <strong>little/no effort</strong> to split into parallel tasks.</li>
<li><strong>GPU fit:</strong> <strong>SIMD/SIMT</strong> executing the <strong>same instructions</strong> over <strong>many data elements</strong>.</li>
<li><strong>Examples:</strong> <strong>video game rendering</strong>, <strong>Bitcoin mining</strong>, <strong>neural networks/AI</strong>.</li>
</ul>
<p><strong>Vertex Translation (Model → World)</strong></p>
<ul>
<li><strong>Object example:</strong> <strong>cowboy hat</strong> with <strong>~28k triangles</strong>, <strong>~14k vertices (x,y,z)</strong>; origin at <strong>(0,0,0)</strong> in <strong>model space</strong>.</li>
<li><strong>World assembly:</strong> place <strong>hundreds of objects</strong> into <strong>world space</strong>; translate each vertex by object’s world origin (and similarly handle rotation/scale in additional steps).</li>
<li><strong>Scene numbers (from talk):</strong> <strong>5,629 objects</strong>, <strong>8.3 million vertices</strong> → <strong>~25 million additions</strong> for translation step.</li>
<li><strong>Key idea:</strong> each vertex transform is <strong>independent</strong> → perfect for <strong>massive parallelism</strong>.</li>
</ul>
</section>
<section id="mapping-computation-to-hardware-simd-simt" class="level2">
<h2 class="anchored" data-anchor-id="mapping-computation-to-hardware-simd-simt">Mapping Computation to Hardware (SIMD → SIMT)</h2>
<ul>
<li><p><strong>Thread:</strong> executes one instruction on one data element (conceptually maps to a CUDA core).</p></li>
<li><p><strong>Warp:</strong> <strong>32 threads</strong> executing the <strong>same instruction sequence</strong>.</p></li>
<li><p><strong>Thread Block:</strong> a group of warps handled by an <strong>SM</strong>; can use <strong>shared L1 cache (128 KB per SM, as stated)</strong> for data sharing.</p></li>
<li><p><strong>Grid:</strong> many blocks across the <strong>entire GPU</strong>.</p></li>
<li><p><strong>Global scheduler:</strong> <strong>Gigathread Engine</strong> maps blocks to SMs.</p></li>
<li><p><strong>SIMT vs SIMD (evolution):</strong></p>
<ul>
<li>Older GPUs: <strong>SIMD lockstep</strong> within warps.</li>
<li>Newer GPUs: <strong>SIMT</strong> — same instruction stream, but <strong>threads can progress at different rates</strong> (each has its <strong>own program counter</strong>).</li>
</ul></li>
<li><p><strong>Warp divergence:</strong> data-dependent branches serialize paths; <strong>reconvergence</strong> at synchronization barriers.</p></li>
</ul>
</section>
<section id="tensor-cores-matrix-engines" class="level2">
<h2 class="anchored" data-anchor-id="tensor-cores-matrix-engines">Tensor Cores — Matrix Engines</h2>
<ul>
<li><strong>Operation form:</strong> <strong>D = A×B + C</strong> (matrix multiply-accumulate) with all three inputs “ready,” executing <strong>concurrently</strong> across tiles.</li>
<li><strong>Use cases:</strong> <strong>neural networks/AI</strong>, <strong>geometric transformations</strong>.</li>
<li><strong>Note:</strong> Ray Tracing Cores covered in a separate video.</li>
</ul>
<p>links:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=h9Z4oGN89MU">How do Graphics Cards Work? Exploring GPU Architecture</a></li>
<li><a href="https://www.youtube.com/watch?v=3l10o0DYJXg">How GPU Computing Works | GTC 2021</a></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>